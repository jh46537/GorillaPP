import chisel3._
import chisel3.util._
import chisel3.util.Fill
import chisel3.util.PriorityEncoder
import chisel3.experimental.ChiselEnum
import chisel3.util.experimental.loadMemoryFromFileInline

import scala.collection.mutable.ArrayBuffer
import scala.collection.mutable.HashMap
import scala.io.Source

// BFU regfile dump interface
class BFU_regfile_req_t(num_threads_lg: Int, num_regs_lg: Int) extends Bundle {
  val tag = UInt(num_threads_lg.W)
  val rdAddr1 = UInt(num_regs_lg.W)
  val rdAddr2 = UInt(num_regs_lg.W)

  override def cloneType = (new BFU_regfile_req_t(num_threads_lg, num_regs_lg).asInstanceOf[this.type])
}

class BFU_regfile_rsp_t(reg_width: Int) extends Bundle {
  val rdData1 = UInt(reg_width.W)
  val rdData2 = UInt(reg_width.W)

  override def cloneType = (new BFU_regfile_rsp_t(reg_width).asInstanceOf[this.type])
}

class Fetch(num: Int, ipWidth: Int, instrWidth: Int, inst_ram_size: Int) extends Module {
  val io = IO(new Bundle {
    val ip         = Input(UInt(ipWidth.W))
    val instr      = Output(UInt(instrWidth.W))
  })

  // FIXME: implement i$

  println("fetch params: ")
  println(" INSTR WIDTH: " + instrWidth)
  println(" NUM_ISNTRS:  " + inst_ram_size)

  val mem = SyncReadMem(inst_ram_size, UInt(instrWidth.W))
  loadMemoryFromFileInline(mem, "./primate_pgm.bin")

  io.instr := mem(io.ip)
}

object ThreadStageEnum extends ChiselEnum {  // ZX: those state control should classified into control unit
    val idle   = Value
    val order_fetch = Value
    val fetch  = Value
    val decode = Value
    val read   = Value
    val pre    = Value
    val exec   = Value
    //val post   = Value
    val branch = Value
}



class primate(extCompName: String) extends gComponentLeaf(new input_t, new output_t, ArrayBuffer(), extCompName + "__type__engine__MT__16__") {
    val filename = "./primate.cfg"
    val fileSource = Source.fromFile(filename)
    val lines = fileSource.getLines.toList
    var knobs:Map[String, String] = Map()
    for (line <- lines) {
        val Array(key, value) = line.split("=")
        knobs += (key -> value)
    }
    
    // global parameters
    val NUM_THREADS = knobs.apply("NUM_THREADS").toInt
    val REG_WIDTH = knobs.apply("REG_WIDTH").toInt
    val NUM_REGS = knobs.apply("NUM_REGS").toInt
    val NUM_BFUS = knobs.apply("NUM_BFUS").toInt + 2 // IO and LSU are hidden lol
    val NUM_ALUS = knobs.apply("NUM_ALUS").toInt
    val IMM_WIDTH = knobs.apply("IMM_WIDTH").toInt
    val NUM_REGBLOCKS = knobs.apply("NUM_REGBLOCKS").toInt
    val NUM_SRC_POS = knobs.apply("NUM_SRC_POS").toInt
    val NUM_SRC_MODES = knobs.apply("NUM_SRC_MODES").toInt
    val NUM_DST_POS = knobs.apply("NUM_DST_POS").toInt
    val NUM_WB_ENS = knobs.apply("NUM_WB_ENS").toInt
    val MAX_FIELD_WIDTH = knobs.apply("MAX_FIELD_WIDTH").toInt
    val IP_WIDTH = knobs.apply("IP_WIDTH").toInt
    val REG_BLOCK_WIDTH:Array[Int] = knobs.apply("REG_BLOCK_WIDTH").split(" ").map(_.toInt)
    val src_pos:Array[Int] = knobs.apply("SRC_POS").split(" ").map(_.toInt)
    val src_mode:Array[Int] = knobs.apply("SRC_MODE").split(" ").map(_.toInt)
    val dst_encode:Array[Long] = knobs.apply("DST_ENCODE").split(" ").map(_.toLong)
    val dst_pos:Array[Long] = knobs.apply("DST_POS").split(" ").map(_.toLong)
    val wbens:Array[Long] = knobs.apply("DST_EN").split(" ").map(_.toLong)
    val dst_en_encode:Array[(Int, Int)] = knobs.apply("DST_EN_ENCODE").split(";").map(_.split(" ") match {case Array(a1, a2) => (a1.toInt, a2.toInt)})
    
    val NUM_THREADS_LG = log2Up(NUM_THREADS)
    val NUM_REGS_LG = log2Up(NUM_REGS)
    val NUM_FUOPS_LG = 6 // currently fixed to 6 due to the risc-v encoding
    val NUM_FUS = (NUM_BFUS).max(NUM_ALUS)
    val NUM_FUS_LG = log2Up(NUM_FUS)
    val NUM_RD_BANKS = scala.math.pow(2, log2Up(NUM_FUS)).toInt
    val NUM_RF_RD_PORTS = NUM_FUS
    val NUM_WR = (NUM_BFUS).max(NUM_ALUS)
    val NUM_RF_WR_PORTS = (NUM_WR+1)/2
    val NUM_WR_BANKS = scala.math.pow(2, log2Up(NUM_RF_WR_PORTS)).toInt
    val NUM_SRC_POS_LG = log2Up(NUM_SRC_POS)
    val NUM_SRC_MODES_LG = log2Up(NUM_SRC_MODES)
    val NUM_DST_POS_LG = log2Up(NUM_DST_POS)
    val NUM_DST_MODES_LG = log2Up(NUM_SRC_MODES)
    val INST_RAM_SIZE = 4096
    // FIXME
    val ALU_SRC_WIDTH = NUM_REGS_LG
    val SUBINSTR_WIDTH: Int = (math.ceil((7 + ALU_SRC_WIDTH * 3 + 3 + 7)/8) * 8).toInt
    val INSTR_WIDTH = SUBINSTR_WIDTH * (NUM_FUS + NUM_ALUS*3 + 1)
    
    val NONE_SELECTED = (NUM_THREADS).U((log2Up(NUM_THREADS+1)).W)
    
    val AllOffloadsReady = Reg(Bool())
    val AllOffloadsValid  = Reg(Vec(NUM_THREADS, Bool()))
    
    /////////////////////
    // DUMP THE PARAMS //
    /////////////////////
    println("PRIMATE PARAMS DUMP")
    println(" NUM_THREADS: " + NUM_THREADS)
    println(" REG_WIDTH: " + REG_WIDTH)
    println(" NUM_REGS: " + NUM_REGS)
    println(" NUM_BFUS: " + NUM_BFUS)
    println(" NUM_ALUS: " + NUM_ALUS)
    println(" NUM_FUS : " + NUM_FUS)
    println(" INSTR_WIDTH: " + INSTR_WIDTH)
    println(" SUBINSTR_WIDTH: " + SUBINSTR_WIDTH)
    
    
    // Global visible Units
    val ioUnit = Module(new inOutUnit(REG_WIDTH, NUM_REGS_LG, NUM_FUOPS_LG, NUM_THREADS, IP_WIDTH))
    
    #ALUBFU_INSTANTIATE#
    // val alu_bfuInst = Array(Module(new alu_bfu0(NUM_THREADS_LG, REG_WIDTH, NUM_FUOPS_LG, NUM_THREADS, IP_WIDTH)),
    //                       Module(new alu_bfu1(NUM_THREADS_LG, REG_WIDTH, NUM_FUOPS_LG, NUM_THREADS, IP_WIDTH)))
    #BFU_INSTANTIATE#

    // output from the alu_bfuInst
    io.mem.mem_addr   := alu_bfuInst(0).io.mem.mem_addr   // ZX: those I/Os are all outputs from the gMemBoudle 
    io.mem.read       := alu_bfuInst(0).io.mem.read       // ZX: So is this assuming those io.mem are the same for each alu_bfu(i) ? 
    io.mem.write      := alu_bfuInst(0).io.mem.write      // ZX: where does io been defined, gInOutOffBundle at the top level?
    io.mem.writedata  := alu_bfuInst(0).io.mem.writedata
    io.mem.byteenable := alu_bfuInst(0).io.mem.byteenable
    // input to the alu_bfuInst
    alu_bfuInst(0).io.mem.waitrequest    := io.mem.waitrequest  // ZX: Those are inputs to the gMemBoudle
    alu_bfuInst(0).io.mem.readdatavalid  := io.mem.readdatavalid
    alu_bfuInst(0).io.mem.readdata       := io.mem.readdata
    for (i <- 1 until NUM_ALUS) {
        alu_bfuInst(i).io.mem.waitrequest   := false.B  // ZX: Taking some default value: always False, why?
        alu_bfuInst(i).io.mem.readdatavalid := false.B
        alu_bfuInst(i).io.mem.readdata      := DontCare
    }
    
    // Gobal unit, init the regfile
    val regfile = Module(new RegRead(NUM_THREADS, NUM_RF_RD_PORTS, NUM_RF_WR_PORTS, NUM_REGS, REG_WIDTH, NUM_REGBLOCKS, REG_BLOCK_WIDTH))
    
    // Gobal unit, init the threadMem and destMems
    class ThreadMemT extends Bundle {
        val brUcodes   = new BRMicrocodes(NUM_ALUS, NUM_FUS)
        val rdWrEn     = Vec(NUM_FUS, Bool())
        val rd         = Vec(NUM_FUS, UInt(NUM_REGS_LG.W))
        val rd_pos     = Vec(NUM_ALUS, UInt(NUM_DST_POS_LG.W))
        val rd_mode    = Vec(NUM_ALUS, UInt(NUM_DST_MODES_LG.W))
    }
    class DestMemT extends Bundle {
        val dstPC      = UInt(32.W)
        val wben       = UInt(NUM_REGBLOCKS.W)
        val dest       = UInt(REG_WIDTH.W)
    }
    val THREAD_MEM_WIDTH = (new ThreadMemT).getWidth
    val threadMem = Module(new ram_simple2port(NUM_THREADS, THREAD_MEM_WIDTH))
    val destMems = Seq.fill(NUM_WR)(Module(new ram_simple2port(NUM_THREADS, (new DestMemT).getWidth)))
    threadMem.io.clock := clock 
    threadMem.io.rden := false.B
    threadMem.io.rdaddress := DontCare
    for (destMem <- destMems) {   
        destMem.io.clock := clock
        destMem.io.wren := false.B
        destMem.io.rden := false.B
        destMem.io.wraddress := DontCare
        destMem.io.rdaddress := DontCare
        destMem.io.data := DontCare
    }

    // global states
    val threadStages = RegInit(VecInit(Seq.fill(NUM_THREADS)(ThreadStageEnum.idle))) 

    val ThreadStateT = new Bundle {         // ZX: controls
        val tag         = UInt((TAGWIDTH*2).W)
        val invalid     = Bool()
        // FIXME: input -> rf & rf -> output
        val ip          = UInt((IP_WIDTH+2).W)
        
        val bfuValids   = Vec(NUM_BFUS, Bool())
        val execValids  = Vec(NUM_BFUS, Bool())
        val io_dstPC    = UInt(IP_WIDTH.W)
        val execDone    = Bool()
        val finish      = Bool()
    }
    val threadStates  = Reg(Vec(NUM_THREADS, ThreadStateT))   // ZX: controls
    // connect the thread to ioUnit
    Range(0, NUM_THREADS, 1).map(i =>  
        ioUnit.io.idle_threads(i) := threadStages(i) === ThreadStageEnum.idle) // idle_threads is bool, and vec
    ioUnit.io.in_valid := io.in.valid
    ioUnit.io.in_tag := io.in.tag
    ioUnit.io.in_data := io.in.bits.data
    ioUnit.io.in_empty := io.in.bits.empty
    ioUnit.io.in_last := io.in.last
    io.in.ready := ioUnit.io.in_ready



    

    /****************** Start Thread *********************************/
    /****************** Scheduler logic *********************************/
    val schedulerLogicBlock = Module(new SchedulerLogic(NUM_THREADS, NUM_RD_BANKS, IP_WIDTH))
    schedulerLogicBlock.io.ioUnit_new_thread := ioUnit.io.new_thread
    schedulerLogicBlock.io.ioUnit_new_tag := ioUnit.io.new_tag
    schedulerLogicBlock.io.threadStages := threadStages
    val vThread = schedulerLogicBlock.io.vThread
    
    
    when (ioUnit.io.new_thread) {
        // spawn new thread
        threadStages(ioUnit.io.new_tag) := ThreadStageEnum.order_fetch 
        threadStates(ioUnit.io.new_tag).ip := 0.U((IP_WIDTH+2).W)           
        println("Primate core spawning new thread!")
    }
    /****************** Fetch logic *********************************/
    val fetchUnit = Module(new Fetch(NUM_THREADS, IP_WIDTH, INSTR_WIDTH, INST_RAM_SIZE))
    val instr = Wire(UInt(INSTR_WIDTH.W))
    fetchUnit.io.ip := (threadStates(vThread).ip)
    instr := fetchUnit.io.instr
    
    when (vThread =/= NONE_SELECTED) {
        threadStages(vThread) := ThreadStageEnum.decode
    }

    /****************** Decode logic *********************************/
    val decodeThread = RegInit(NONE_SELECTED) //assume this declared outside, make this as the input
    decodeThread := vThread
    val decodeThread_d1 = RegNext(decodeThread)  //assume this declared outside, make this as the input

    val decodeLogicBlock = Module(new DecodeLogic(NUM_ALUS, NUM_BFUS, NUM_FUS, INSTR_WIDTH, SUBINSTR_WIDTH, ALU_SRC_WIDTH, NUM_SRC_POS_LG, 
                                                  NUM_SRC_MODES_LG, NUM_DST_POS_LG,  NUM_DST_MODES_LG, NUM_THREADS, NUM_THREADS_LG, NUM_REGS_LG, 
                                                  REG_WIDTH, THREAD_MEM_WIDTH, NUM_RF_RD_PORTS))

    val decodeUnit_bfuValids = Wire(Vec(NUM_BFUS, Bool()))  // !Make sure!
    val aluMicrocodes_in = Wire(new ALUMicrocodes(NUM_ALUS, ALU_SRC_WIDTH, NUM_SRC_POS_LG, NUM_SRC_MODES_LG))
    val bfuMicrocodes_in = Wire(new BFUMicrocodes(NUM_FUS-NUM_ALUS, ALU_SRC_WIDTH))  
    val rdWrEn_in = Wire(Vec(NUM_FUS, Bool()))   // ZX: never used
    val bfuValids_in = Wire(Vec(NUM_BFUS, Bool()))
    // val bfuRdRspQ_almFull = Wire(Bool())
    val bfuRdRspQ_enq_in = Wire(Bool())
    
    // Output from the decodeLogicBlock
    decodeUnit_bfuValids := decodeLogicBlock.io.decodeUnit_bfuValids
    aluMicrocodes_in := decodeLogicBlock.io.aluMicrocodes_in
    bfuMicrocodes_in := decodeLogicBlock.io.bfuMicrocodes_in
    rdWrEn_in := decodeLogicBlock.io.rdWrEn_in
    bfuValids_in := decodeLogicBlock.io.bfuValids_in
    bfuRdRspQ_enq_in := decodeLogicBlock.io.bfuRdRspQ_enq_in
    ioUnit.io.rd_req_ready := decodeLogicBlock.io.ioUnit_rd_req_ready
    ioUnit.io.rd_rsp_valid := decodeLogicBlock.io.ioUnit_rd_rsp_valid
    ioUnit.io.rd_rsp := decodeLogicBlock.io.ioUnit_rd_rsp
    threadMem.io.wraddress := decodeLogicBlock.io.threadMem_wraddress
    threadMem.io.wren := decodeLogicBlock.io.threadMem_wren
    threadMem.io.data := decodeLogicBlock.io.threadMem_data
    regfile.io.thread_rd := decodeLogicBlock.io.regfile_thread_rd
    regfile.io.rdEn := decodeLogicBlock.io.regfile_rdEn
    regfile.io.rdAddr1:= decodeLogicBlock.io.regfile_rdAddr1
    regfile.io.rdAddr2:= decodeLogicBlock.io.regfile_rdAddr2

    // inputs to the decodeLogicBlock
    decodeLogicBlock.io.instr := instr
    decodeLogicBlock.io.decodeThread := decodeThread
    decodeLogicBlock.io.decodeThread_d1 := decodeThread_d1
    decodeLogicBlock.io.ioUnit_rd_req_valid := ioUnit.io.rd_req_valid
    decodeLogicBlock.io.ioUnit_rd_req := ioUnit.io.rd_req
    decodeLogicBlock.io.ioUnit_rd_rsp_ready := ioUnit.io.rd_rsp_ready

    when (decodeThread =/= NONE_SELECTED) {
        threadStates(decodeThread).bfuValids := decodeUnit_bfuValids 
        threadStates(decodeThread).invalid := false.B    
        threadStates(decodeThread).execValids := VecInit(Seq.fill(NUM_BFUS)(false.B))
        threadStages(decodeThread) := ThreadStageEnum.read
    } 
    .otherwise {
        threadStates(decodeThread).bfuValids := DontCare
        threadStates(decodeThread).execValids := DontCare
    }

  /***************** Register read / Metadata FIFO enq *************************/
  val REG_DELAY = NUM_RF_RD_PORTS + 1
  val ALU_DELAY = 3 // 3 (gather)

  val readThread_vec = RegInit(VecInit(Seq.fill(REG_DELAY+ALU_DELAY)(NONE_SELECTED)))
  val aluMicrocodes_vec = Reg(Vec(REG_DELAY, new ALUMicrocodes(NUM_ALUS, ALU_SRC_WIDTH, NUM_SRC_POS_LG, NUM_SRC_MODES_LG)))
  val bfuMicrocodes_vec = Reg(Vec(REG_DELAY, new BFUMicrocodes(NUM_FUS-NUM_ALUS, ALU_SRC_WIDTH)))
  val bfuValids_vec = RegInit(VecInit(Seq.fill(REG_DELAY)(VecInit(Seq.fill(NUM_BFUS)(false.B)))))
  val bfuRdRspQ_enq_vec = RegInit(VecInit(Seq.fill(REG_DELAY)(false.B)))

  readThread_vec(REG_DELAY+ALU_DELAY-1) := decodeThread
  aluMicrocodes_vec(REG_DELAY-1) := aluMicrocodes_in
  bfuMicrocodes_vec(REG_DELAY-1) := bfuMicrocodes_in
  bfuValids_vec(REG_DELAY-1) := bfuValids_in
  bfuRdRspQ_enq_vec(REG_DELAY-1) := bfuRdRspQ_enq_in

  for (i <- 0 until REG_DELAY+ALU_DELAY-1) {
    readThread_vec(i) := readThread_vec(i+1)
  }
  for (i <- 0 until REG_DELAY-1) {
    aluMicrocodes_vec(i) := aluMicrocodes_vec(i+1)
    bfuMicrocodes_vec(i) := bfuMicrocodes_vec(i+1)
    bfuValids_vec(i) := bfuValids_vec(i+1)
    bfuRdRspQ_enq_vec(i) := bfuRdRspQ_enq_vec(i+1)
  }

  val srcA = Wire(Vec(NUM_FUS, UInt(REG_WIDTH.W))) // vector containing all the RS1s read from the regfile
  val srcB = Wire(Vec(NUM_FUS, UInt(REG_WIDTH.W))) // vector containing all the RS2s read from the regfile
  srcA := regfile.io.rdData1
  srcB := regfile.io.rdData2  // what is the purpose 

  // moved from Gather stage to here
  val bfuRdRspQ_enq_valid = bfuRdRspQ_enq_vec(0)
  val bfuRdRspQ_enq_bits = Wire(new BFU_regfile_rsp_t(REG_WIDTH))

  // BFU regfile dump rsp queue
  bfuRdRspQ_enq_bits.rdData1 := srcA(0)
  bfuRdRspQ_enq_bits.rdData2 := srcB(0)
  decodeLogicBlock.io.bfuRdRspQ_enq_valid := bfuRdRspQ_enq_valid
  decodeLogicBlock.io.bfuRdRspQ_enq_bits := bfuRdRspQ_enq_bits 


    /****************** Gather Stage 0-2 *************************/
    val gatherThread = readThread_vec(ALU_DELAY) 
    val aluMicrocodes_out = aluMicrocodes_vec(0)  
    val bfuMicrocodes_out = bfuMicrocodes_vec(0)  
    val bfuValids_out = bfuValids_vec(0)          
    
    val gather_srcA = Seq.fill(NUM_ALUS)(Module(new Gather(REG_WIDTH, NUM_SRC_POS, src_pos, MAX_FIELD_WIDTH, NUM_SRC_MODES, src_mode)))
    val gather_srcB = Seq.fill(NUM_ALUS)(Module(new Gather(REG_WIDTH, NUM_SRC_POS, src_pos, MAX_FIELD_WIDTH, NUM_SRC_MODES, src_mode)))  
    for (i <- 0 until NUM_ALUS) {
        gather_srcA(i).io.din   := srcA(i)    // srcA(i) is the input (val srcA = Wire(Vec(NUM_FUS, UInt(REG_WIDTH.W))))
        gather_srcA(i).io.shift := aluMicrocodes_out.rs1_pos(i)
        gather_srcA(i).io.mode  := aluMicrocodes_out.rs1_mode(i)
        gather_srcB(i).io.din   := srcB(i)
        gather_srcB(i).io.shift := aluMicrocodes_out.rs2_pos(i)
        gather_srcB(i).io.mode  := aluMicrocodes_out.rs2_mode(i)
    }
    
    // BFU FIFOs
    val execBundle_io = new Bundle {
        val tag = UInt(NUM_THREADS_LG.W)
        val opcode = UInt(NUM_FUOPS_LG.W)
        val rd = UInt(NUM_REGS_LG.W)
        val imm = UInt(12.W)
        val bits = UInt(REG_WIDTH.W)
    }
    
    val fuFifos_iou = Module(new Queue(execBundle_io, NUM_THREADS))
    fuFifos_iou.io.enq.valid := false.B
    fuFifos_iou.io.enq.bits := DontCare
    
    val gatherLogicBlock = Module(new gatherLogic(NUM_THREADS, NUM_BFUS, NUM_ALUS, NUM_FUS, REG_WIDTH, NUM_THREADS_LG, NUM_REGS_LG, 
                                                  NUM_FUOPS_LG, ALU_SRC_WIDTH, NUM_SRC_POS_LG, NUM_SRC_MODES_LG, NONE_SELECTED))
    // inputs
    gatherLogicBlock.io.gatherThread := gatherThread
    gatherLogicBlock.io.aluMicrocodes_out := aluMicrocodes_out
    gatherLogicBlock.io.bfuMicrocodes_out := bfuMicrocodes_out
    gatherLogicBlock.io.bfuValids_out := bfuValids_out
    gatherLogicBlock.io.srcA := srcA

    // Outputs
    fuFifos_iou.io.enq.valid := gatherLogicBlock.io.fuFifos_enq_valid
    fuFifos_iou.io.enq.bits.tag := gatherLogicBlock.io.fuFifos_enq_bits_tag
    fuFifos_iou.io.enq.bits.opcode := gatherLogicBlock.io.fuFifos_enq_bits_opcode
    fuFifos_iou.io.enq.bits.rd := gatherLogicBlock.io.fuFifos_enq_bits_rd
    fuFifos_iou.io.enq.bits.imm := gatherLogicBlock.io.fuFifos_enq_bits_imm
    fuFifos_iou.io.enq.bits.bits:= gatherLogicBlock.io.fuFifos_enq_bits_bits

    #FIFO_INSTANTIATE#
    #FIFO_INPUT#


  /****************** ALU/BFU Stage 0 *************************/
  val preOpThread = readThread_vec(0)
  // ALUBFU FIFOs
  class execBundle_alu extends Bundle {
    val tag     = UInt(NUM_THREADS_LG.W)
    val opcode  = UInt(NUM_FUOPS_LG.W)
    val alu_bfu = Bool()
    val rs1     = UInt(REG_WIDTH.W)
    val rs2     = UInt(32.W)
    val addEn   = Bool()
    val subEn   = Bool()
    val sltEn   = Bool()
    val sltuEn  = Bool()
    val andEn   = Bool()
    val orEn    = Bool()
    val xorEn   = Bool()
    val sllEn   = Bool()
    val srEn    = Bool()
    val srMode  = Bool()
    val luiEn   = Bool()
    val catEn   = Bool()
    val immSel  = Bool()
    val imm     = SInt(32.W)
  }
  val fuFifos_alu = Seq.fill(NUM_ALUS)(Module(new Queue(new execBundle_alu, NUM_THREADS)))

  val aluMicrocodes_out_d0 = RegNext(aluMicrocodes_out)
  val aluMicrocodes_out_d1 = RegNext(aluMicrocodes_out_d0)
  val aluMicrocodes_out_d2 = RegNext(aluMicrocodes_out_d1)

  for (i <- 0 until NUM_ALUS) {
    fuFifos_alu(i).io.enq.valid := false.B
    fuFifos_alu(i).io.enq.bits := DontCare
    when (preOpThread =/= NONE_SELECTED) {
      val fuFifos_alu_in = Wire(new execBundle_alu)
      fuFifos_alu_in.tag     := preOpThread
      fuFifos_alu_in.opcode  := aluMicrocodes_out_d2.opcode(i)
      fuFifos_alu_in.alu_bfu := aluMicrocodes_out_d2.bfu_valid(i)
      fuFifos_alu_in.rs1     := gather_srcA(i).io.dout
      fuFifos_alu_in.rs2     := gather_srcB(i).io.dout
      fuFifos_alu_in.addEn   := aluMicrocodes_out_d2.addEn(i)
      fuFifos_alu_in.subEn   := aluMicrocodes_out_d2.subEn(i)
      fuFifos_alu_in.sltEn   := aluMicrocodes_out_d2.sltEn(i)
      fuFifos_alu_in.sltuEn  := aluMicrocodes_out_d2.sltuEn(i)
      fuFifos_alu_in.andEn   := aluMicrocodes_out_d2.andEn(i)
      fuFifos_alu_in.orEn    := aluMicrocodes_out_d2.orEn(i)
      fuFifos_alu_in.xorEn   := aluMicrocodes_out_d2.xorEn(i)
      fuFifos_alu_in.sllEn   := aluMicrocodes_out_d2.sllEn(i)
      fuFifos_alu_in.srEn    := aluMicrocodes_out_d2.srEn(i)
      fuFifos_alu_in.srMode  := aluMicrocodes_out_d2.srMode(i)
      fuFifos_alu_in.luiEn   := aluMicrocodes_out_d2.luiEn(i)
      fuFifos_alu_in.catEn   := aluMicrocodes_out_d2.catEn(i)
      fuFifos_alu_in.immSel  := aluMicrocodes_out_d2.immSel(i)
      fuFifos_alu_in.imm     := aluMicrocodes_out_d2.imm(i)
      fuFifos_alu(i).io.enq.bits := fuFifos_alu_in
      fuFifos_alu(i).io.enq.valid := true.B
    } .otherwise {
      fuFifos_alu(i).io.enq.bits := DontCare
      fuFifos_alu(i).io.enq.valid := false.B
    }
  }

  /****************** Function unit execution *********************************/  // No need to refactor
  val execThread = RegInit(NONE_SELECTED)  
  execThread := preOpThread
  val execThread_d0 = RegNext(execThread) 
    
  // FUs
  for (i <- 0 until NUM_ALUS) {
    fuFifos_alu(i).io.deq.ready := false.B
    alu_bfuInst(i).io.in_valid := false.B
    val deq = fuFifos_alu(i).io.deq.bits
    alu_bfuInst(i).io.in_alu_bfu := deq.alu_bfu
    alu_bfuInst(i).io.in_tag     := deq.tag
    alu_bfuInst(i).io.in_opcode  := deq.opcode
    alu_bfuInst(i).io.in_rs1     := deq.rs1
    alu_bfuInst(i).io.in_rs2     := deq.rs2
    alu_bfuInst(i).io.in_addEn   := deq.addEn
    alu_bfuInst(i).io.in_subEn   := deq.subEn
    alu_bfuInst(i).io.in_sltEn   := deq.sltEn
    alu_bfuInst(i).io.in_sltuEn  := deq.sltuEn
    alu_bfuInst(i).io.in_andEn   := deq.andEn
    alu_bfuInst(i).io.in_orEn    := deq.orEn
    alu_bfuInst(i).io.in_xorEn   := deq.xorEn
    alu_bfuInst(i).io.in_sllEn   := deq.sllEn
    alu_bfuInst(i).io.in_srEn    := deq.srEn
    alu_bfuInst(i).io.in_srMode  := deq.srMode
    alu_bfuInst(i).io.in_luiEn   := deq.luiEn
    alu_bfuInst(i).io.in_catEn   := deq.catEn
    alu_bfuInst(i).io.in_immSel  := deq.immSel
    alu_bfuInst(i).io.in_imm     := deq.imm
    when (fuFifos_alu(i).io.deq.valid) {
      alu_bfuInst(i).io.in_valid := true.B
      when (alu_bfuInst(i).io.in_ready) {
        fuFifos_alu(i).io.deq.ready := true.B
      }
    }
  }

  fuFifos_iou.io.deq.ready := false.B
  when (fuFifos_iou.io.deq.valid) {
    val deq = fuFifos_iou.io.deq
    ioUnit.io.ar_valid := true.B
    ioUnit.io.ar_tag := deq.bits.tag
    ioUnit.io.ar_opcode := deq.bits.opcode
    ioUnit.io.ar_rd := deq.bits.rd
    ioUnit.io.ar_bits := deq.bits.bits
    ioUnit.io.ar_imm := deq.bits.imm
    when (ioUnit.io.ar_ready) {
      fuFifos_iou.io.deq.ready := true.B
    }
  } .otherwise {
    ioUnit.io.ar_valid := false.B
    ioUnit.io.ar_tag := DontCare
    ioUnit.io.ar_opcode := DontCare
    ioUnit.io.ar_rd := DontCare
    ioUnit.io.ar_bits := DontCare
    ioUnit.io.ar_imm := DontCare
  }

  #BFU_INPUT#

  when (execThread_d0 =/= NONE_SELECTED) {
    threadStages(execThread_d0) := ThreadStageEnum.exec
  }

  // FUs output
  for (i <- 0 until NUM_ALUS) {
    alu_bfuInst(i).io.out_ready := true.B
    when (alu_bfuInst(i).io.out_valid) {
      val destMem_in = Wire(new DestMemT)
      destMem_in.dstPC := alu_bfuInst(i).io.out_flag
      destMem_in.dest := alu_bfuInst(i).io.out_bits
      destMem_in.wben := Fill(NUM_REGBLOCKS, 1.U)
      destMems(i).io.wren := true.B
      destMems(i).io.wraddress := alu_bfuInst(i).io.out_tag
      destMems(i).io.data := destMem_in.asUInt
      threadStates(alu_bfuInst(i).io.out_tag).execValids(i) := true.B
    }
  }

  when (ioUnit.io.w_valid) {
    threadStates(ioUnit.io.w_tag).execValids(NUM_BFUS-1) := true.B
    threadStates(ioUnit.io.w_tag).io_dstPC := ioUnit.io.w_flag
  }
  when (ioUnit.io.r_valid) {
    threadStates(ioUnit.io.r_tag).execValids(NUM_BFUS-1) := true.B
    threadStates(ioUnit.io.r_tag).io_dstPC := ioUnit.io.r_flag
  }

  #BFU_OUTPUT#

    /****************** Finish execution *********************************/
    val finishExecutionLogicBlock = Module(new FinishExecutionLogic(NUM_THREADS, NUM_WR, NUM_WR_BANKS, NUM_BFUS, NONE_SELECTED))

    // Provide inputs to the extracted module
    finishExecutionLogicBlock.io.threadStates_execValids := threadStates.map(_.execValids)
    finishExecutionLogicBlock.io.threadStates_bfuValids := threadStates.map(_.bfuValids)
    finishExecutionLogicBlock.io.threadStages := threadStages
    
    // Extract outputs from the module
    val fThread = finishExecutionLogicBlock.io.fThread
    threadMem.io.rden := finishExecutionLogicBlock.io.threadMem_rden
    threadMem.io.rdaddress := finishExecutionLogicBlock.io.threadMem_rdaddress
    
    for (i <- 0 until NUM_WR) {
        destMems(i).io.rden := finishExecutionLogicBlock.io.destMems_rden(i)
        destMems(i).io.rdaddress := finishExecutionLogicBlock.io.destMems_rdaddress(i)
    }

    when (fThread =/= NONE_SELECTED) {
        threadStages(fThread) := ThreadStageEnum.branch
    }


  /****************** Register write & branch *********************************/
  val WB_DELAY = NUM_RF_WR_PORTS.max(3)
  val branchThread_out = RegInit(NONE_SELECTED)   // where does this go
  val branchThread_vec = RegInit(VecInit(Seq.fill(WB_DELAY)(NONE_SELECTED)))
  branchThread_out := branchThread_vec(0)
  // val branchU = Module(new BranchUnit)  // local module, define it in the submodule

  branchThread_vec(WB_DELAY-1) := fThread
  for (i <- 0 until WB_DELAY-1) {
    branchThread_vec(i) := branchThread_vec(i+1)   // Ater update the value make branchThread_vec as an input
  }
    
  //// excluded and remain on the top level, start (this part is assign values to the input)
  val threadMem_out = Wire(new ThreadMemT)  // defined at the top level, but also a input
  val destMems_out = Wire(Vec(NUM_WR, (new DestMemT))) // execluded from module, live at top level
  val destWbens_wb = RegInit(VecInit(Seq.fill(NUM_WR)(0.U(NUM_REGBLOCKS.W)))) // input
  val dests_wb = Wire(Vec(NUM_WR, UInt(REG_WIDTH.W)))  // input
  val dstPCs = Wire(Vec(NUM_FUS+3*NUM_ALUS, UInt(32.W)))  // input

  
  dstPCs := DontCare
  if (NUM_ALUS < NUM_FUS) {
    // The last unit is the IO unit
    for (i <- 0 until NUM_FUS-1) {
      destMems_out(i) := destMems(i).io.q.asTypeOf(new DestMemT) 
      dests_wb(i) := destMems_out(i).dest
      destWbens_wb(i) := destMems_out(i).wben
    }
    for (i <- 0 until NUM_ALUS) {
      dstPCs(4*i+2) := destMems_out(i).dstPC
    }
    for (i <- 0 until NUM_FUS-NUM_ALUS-1) {
      dstPCs(4*NUM_ALUS+i) := destMems_out(NUM_ALUS+i).dstPC
    }
    dstPCs(NUM_FUS+3*NUM_ALUS-1) := threadStates(branchThread_vec(WB_DELAY-2)).io_dstPC
  } else {
    // The IO unit is combined with an ALU unit
    for (i <- 0 until NUM_FUS) {
      destMems_out(i) := destMems(i).io.q.asTypeOf(new DestMemT)
      dests_wb(i) := destMems_out(i).dest
      destWbens_wb(i) := destMems_out(i).wben
    }
    for (i <- 0 until NUM_ALUS) {
      dstPCs(4*i+2) := destMems_out(i).dstPC
    }
    dstPCs(4*(NUM_BFUS-1)+2) := threadStates(branchThread_vec(WB_DELAY-2)).io_dstPC
  }
    
  threadMem_out := threadMem.io.q.asTypeOf(chiselTypeOf(threadMem_out)) 

  val pc = Reg(UInt((IP_WIDTH+2).W))  
  val threadValid = RegInit(false.B)  

  when (branchThread_vec(WB_DELAY-1) =/= NONE_SELECTED) {
    threadValid := true.B
    pc := threadStates(branchThread_vec(WB_DELAY-1)).ip
  } .otherwise {
    threadValid := false.B
    pc := DontCare
  }
  ///// execluded end
  val threadValid_s1 = RegNext(threadValid)
  val threadValid_s2 = RegNext(threadValid_s1)

  val wbBranchBlock = Module(new RegisterWriteAndBranchLogic(NUM_THREADS,NUM_WR, NUM_FUS, NUM_ALUS, NUM_REGS, NUM_RF_WR_PORTS, NUM_REGBLOCKS, NUM_SRC_POS_LG, 
                                                             NUM_DST_POS_LG, NUM_SRC_MODES_LG, REG_WIDTH, IP_WIDTH, NUM_REGS_LG, NUM_DST_MODES_LG, NUM_DST_POS, 
                                                             WB_DELAY, dst_encode, dst_pos, NUM_WB_ENS, dst_en_encode, wbens))
  
    wbBranchBlock.io.branchThread_vec := branchThread_vec
    wbBranchBlock.io.threadMem_out := threadMem_out
    wbBranchBlock.io.destWbens_wb := destWbens_wb
    wbBranchBlock.io.dests_wb := dests_wb
    wbBranchBlock.io.dstPCs := dstPCs
    wbBranchBlock.io.threadValid := threadValid
    wbBranchBlock.io.pc := pc
    wbBranchBlock.io.ioUnit_w_tag := ioUnit.io.w_tag
    wbBranchBlock.io.ioUnit_w_wen := ioUnit.io.w_wen
    wbBranchBlock.io.ioUnit_w_addr := ioUnit.io.w_addr
    wbBranchBlock.io.ioUnit_w_data := ioUnit.io.w_data

    val thread_finish = Wire(Bool())
    val thread_new_pc = Wire(UInt((IP_WIDTH+2).W))
    
    thread_finish := wbBranchBlock.io.thread_finish
    thread_new_pc:= wbBranchBlock.io.thread_new_pc
    regfile.io.wrEn := wbBranchBlock.io.regfile_wrEn
    regfile.io.thread_wr := wbBranchBlock.io.regfile_thread_wr
    regfile.io.wrEn1 := wbBranchBlock.io.regfile_wrEn1
    regfile.io.wrAddr1 := wbBranchBlock.io.regfile_wrAddr1
    regfile.io.wrBen1 := wbBranchBlock.io.regfile_wrBen1
    regfile.io.wrData1 := wbBranchBlock.io.regfile_wrData1
    regfile.io.wrEn2 := wbBranchBlock.io.regfile_wrEn2
    regfile.io.wrAddr2 := wbBranchBlock.io.regfile_wrAddr2
    regfile.io.wrBen2 := wbBranchBlock.io.regfile_wrBen2
    regfile.io.wrData2 := wbBranchBlock.io.regfile_wrData2
    
  when (threadValid_s1) {
    threadStates(branchThread_vec(WB_DELAY-3)).ip := thread_new_pc
    when (thread_finish) {
      threadStages(branchThread_vec(WB_DELAY-3)) := ThreadStageEnum.idle
    } .otherwise {
      threadStages(branchThread_vec(WB_DELAY-3)) := ThreadStageEnum.fetch
    }
  } .elsewhen (branchThread_vec(WB_DELAY-3) =/= NONE_SELECTED) {
    threadStages(branchThread_vec(WB_DELAY-3)) := ThreadStageEnum.fetch
  }


  // Output
  io.out.valid := ioUnit.io.out_valid
  io.out.tag := ioUnit.io.out_tag
  io.out.bits.data := ioUnit.io.out_data
  io.out.bits.empty := ioUnit.io.out_empty
  io.out.last := ioUnit.io.out_last
  ioUnit.io.out_ready := io.out.ready

  // Input unit output ready
  val w_tag = ioUnit.io.w_tag
  val lastThreadWr = RegNext(branchThread_vec(WB_DELAY-3))
  ioUnit.io.w_ready := (!threadValid_s1) && ((!threadValid_s2) || (w_tag(log2Up(NUM_RF_WR_PORTS)-1, 0) =/= lastThreadWr(log2Up(NUM_RF_WR_PORTS)-1, 0)))

}
